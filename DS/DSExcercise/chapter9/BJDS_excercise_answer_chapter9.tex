\documentclass[lang=cn,newtx,10pt,scheme=chinese]{../../../elegantbook}

\title{基础提高练习题}
\subtitle{北街学长倾力之作}

\author{北街}
% \institute{Elegant\LaTeX{} Program}
\date{2022/12/31}
\version{1.0}
% \bioinfo{自定义}{信息}

% \extrainfo{注意：本模板自 2023 年 1 月 122222 日开始，不再更新和维护！}

\setcounter{tocdepth}{3}

\logo{../../figure/logo-blue.png}
\cover{../../figure/cover.jpg}

% 本文档命令
\usepackage{array}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}

% 修改标题页的橙色带
\definecolor{customcolor}{RGB}{32,178,170}
\colorlet{coverlinecolor}{customcolor}
\usepackage{cprotect}

\addbibresource[location=local]{reference.bib} % 参考文献，不要删除
\usepackage{listings}         % 导入listings宏包
\usepackage{xcolor}           % 支持颜色

% 配置C++代码样式
\lstset{
    language=C++,             % 语言设置为C++
    basicstyle=\ttfamily,      % 基本样式
    keywordstyle=\color{blue}, % 关键词颜色
    commentstyle=\color{green},% 注释颜色
    stringstyle=\color{red},   % 字符串颜色
    numbers=left,              % 显示行号
    numberstyle=\tiny,         % 行号样式
    stepnumber=1,              % 每行显示行号
    breaklines=true,           % 自动换行
    frame=lines                % 代码块边框样式
}
\begin{document}

\maketitle
\frontmatter

\tableofcontents

\mainmatter



\begin{enumerate}
    \item 选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是（ ）。  
    【2019 年全国试题 7（2 分）】  

    I. 数据的规模  

    II. 数据的存储方式  

    III. 算法的稳定性  

    IV. 数据的初始状态  

    答案:\textcolor{red}{D}

    解析：\\
    1. 数据的规模决定了算法的时间复杂度是否适用。\\
    2. 数据的存储方式影响算法的实现，例如链式存储或顺序存储。\\
    3. 算法的稳定性在某些应用场景中非常重要，例如需要保持相同关键字的相对顺序。\\
    4. 数据的初始状态（如是否接近有序）会影响某些算法的性能，例如插入排序在接近有序时效率更高。\\
    5. 因此，答案为 \textcolor{red}{D}。\\

\item 排序过程中，快速排序的“第二趟”结果。下列序列中，不可能是快速排序第二趟结果的是（ ）。  
    【2019 年全国试题 10（2 分）】  

    A. $5, 2, 16, 12, 28, 60, 32, 72$ \\  
    B. $2, 16, 5, 28, 12, 60, 32, 72$ \\  
    C. $2, 12, 16, 5, 28, 32, 72, 60$ \\  
    D. $5, 2, 12, 28, 16, 32, 72, 60$ \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 快速排序的每一趟排序会将一个基准元素放到其最终位置，并将序列分为两部分。\\
    2. 选项 C 中，$16$ 和 $5$ 的位置不符合快速排序的分区规则，因此不可能是第二趟结果。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 设外存上有 120 个初始归并段，进行 12 路归并时，为实现最佳归并，需要补充的虚段个数是（ ）。  
    【2019 年全国试题 11（2 分）】  

    A. 1 \\  
    B. 2 \\  
    C. 3 \\  
    D. 4 \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 归并段数需要补充到 $12^k$ 的形式，其中 $k$ 为正整数。\\
    2. $120$ 补充 $3$ 个虚段后变为 $123$，满足 $12^2 = 144$ 的条件。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 对初始数据序列 $\{8, 3, 9, 11, 2, 1, 4, 7, 5, 10, 6\}$ 进行希尔排序。若第一趟排序结果为 $\{1, 3, 7, 5, 2, 6, 4, 9, 11, 10, 8\}$，第二趟排序结果为 $\{1, 2, 6, 4, 3, 7, 5, 8, 11, 10, 9\}$，则两趟排序采用的增量（间隔）依次是（ ）。  
    【2018 年全国试题 10（2 分）】  

    A. 3, 1 \\  
    B. 3, 2 \\  
    C. 5, 2 \\  
    D. 5, 3 \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 希尔排序的增量序列决定了分组方式。\\
    2. 第一趟排序结果表明数据被分为 5 组，第二趟排序结果表明数据被分为 2 组。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 在将数据序列 $\{6, 1, 5, 9, 8, 4, 7\}$ 建成大根堆时，正确的序列变化过程是（ ）。  
    【2018 年全国试题 11（2 分）】  

    答案:\textcolor{red}{C}

    解析：\\
    1. 大根堆的构建过程需要从最后一个非叶子节点开始调整。\\
    2. 选项 C 中的变化过程符合大根堆的调整规则。\\
    3. 因此，答案为 \textcolor{red}{C}。\\


    \item 在内部排序时，若选择了归并排序而没有选择插入排序，则可能的理由是（ ）。  
    【2017 年全国试题 10（2 分）】  

    I. 归并排序的程序代码更短  

    II. 归并排序占的空间更少  

    III. 归并排序的运行效率更高  

    答案:\textcolor{red}{B}

    解析：\\
    1. 归并排序的时间复杂度为 $O(n \log n)$，而插入排序的最坏时间复杂度为 $O(n^2)$，因此归并排序的运行效率更高。\\
    2. 归并排序需要额外的空间，而插入排序是原地排序，因此归并排序占用的空间更多。\\
    3. 程序代码的长短与排序方法无直接关系。\\
    4. 因此，答案为 \textcolor{red}{B}。\\

\item 下列排序方法中，若将顺序存储更换为链式存储，有时则效率更高的是（ ）。  
    【2017 年全国试题 11（2 分）】  

    I. 插入排序  

    II. 选择排序  

    III. 冒泡排序  

    IV. 希尔排序  

    V. 堆排序  

    答案:\textcolor{red}{A}

    解析：\\
    1. 插入排序在链式存储中可以直接插入到合适位置，无需移动元素，因此效率更高。\\
    2. 选择排序和冒泡排序在链式存储中效率不会显著提高。\\
    3. 希尔排序和堆排序依赖于随机访问，链式存储会降低效率。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

\item 对 10TB 的数据文件进行排序，应使用的方法是（ ）。  
    【2016 年全国试题 11（2 分）】  

    A. 希尔排序 \\  
    B. 堆排序 \\  
    C. 快速排序 \\  
    D. 归并排序 \\  

    答案:\textcolor{red}{D}

    解析：\\
    1. 对于大规模数据文件，归并排序适合外部排序，能够有效处理数据量超出内存容量的情况。\\
    2. 希尔排序、堆排序和快速排序主要用于内部排序，不适合处理外部数据。\\
    3. 因此，答案为 \textcolor{red}{D}。\\

\item 下列排序算法中，（ ）每一趟都能选出一个元素放在其最终位置上，并且是不稳定的。  
    【北京大学 2016 一、9（2 分）】  

    A. 冒泡排序 \\  
    B. 希尔排序 \\  
    C. 简单选择排序 \\  
    D. 快速排序 \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 简单选择排序每一趟都能选出一个最小（或最大）元素放在其最终位置上，但它是不稳定的排序方法。\\
    2. 冒泡排序是稳定的，希尔排序和快速排序不一定每趟确定一个元素的最终位置。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 若一组记录的关键字为 $\{45, 80, 55, 40, 42, 85\}$，则利用堆排序方法建立的初始堆为（ ）。  
    【吉林大学 2017 一、2（2 分）】  

    A. $80, 45, 55, 40, 42, 85$ \\  
    B. $85, 80, 55, 40, 42, 45$ \\  
    C. $85, 80, 55, 45, 42, 40$ \\  
    D. $85, 55, 80, 42, 45, 40$ \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 堆排序的初始堆是一个大根堆，根节点为最大值，子节点满足堆的性质。\\
    2. 选项 C 中的堆符合大根堆的定义。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 已知关键字序列 $\{5, 8, 12, 19, 28, 20, 15, 22\}$ 是小根堆（最小堆），插入关键字 3，调整后得到的小根堆是（ ）。  
    【2009 年全国试题 9（2 分）】  

    A. $3, 5, 12, 8, 28, 20, 15, 22, 19$ \\  
    B. $3, 5, 12, 19, 20, 15, 22, 8, 28$ \\  
    C. $3, 8, 12, 5, 20, 15, 22, 28, 19$ \\  
    D. $3, 12, 5, 8, 28, 20, 15, 22, 19$ \\  

    答案:\textcolor{red}{A}

    解析：\\
    1. 插入关键字 3 后，将其放在堆的末尾，然后向上调整以满足小根堆的性质。\\
    2. 选项 A 中的堆符合调整后的小根堆结构。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 若数据元素序列 $\{11, 12, 13, 7, 8, 9, 23, 4, 5\}$ 是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是（ ）。  
    【2009 年全国试题 10（2 分）】  

    A. 冒泡排序 \\  
    B. 插入排序 \\  
    C. 选择排序 \\  
    D. 二路归并排序 \\  

    答案:\textcolor{red}{B}

    解析：\\
    1. 插入排序在第二趟后，前两个元素已经有序，后续元素逐步插入到合适位置。\\
    2. 选项 B 符合插入排序的特点。\\
    3. 因此，答案为 \textcolor{red}{B}。\\

\item 采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是（ ）。  
    【2010 年全国试题 10（2 分）】  

    A. 递归次数与初始数据的排列次序无关 \\  
    B. 每次划分后，先处理较长的分区可以减少递归次数 \\  
    C. 每次划分后，先处理较短的分区可以减少递归次数 \\  
    D. 递归次数与每次划分后得到的分区的处理顺序无关 \\  

    答案:\textcolor{red}{C}

    解析：\\
    1. 快速排序中，先处理较短的分区可以减少递归深度，从而减少递归次数。\\
    2. 因此，答案为 \textcolor{red}{C}。\\

    \item 对一组数据 $\{2, 12, 16, 88, 5, 10\}$ 进行排序，若前三趟排序结果如下：\\
    第一趟排序结果：$2, 12, 16, 5, 10, 88$ \\  
    第二趟排序结果：$2, 12, 5, 10, 16, 88$ \\  
    第三趟排序结果：$2, 5, 10, 12, 16, 88$ \\  
    则采用的排序方法可能是（ ）。\\
    【2010 年全国试题 11（2 分）】\\

    A. 冒泡排序 \quad B. 希尔排序 \quad C. 归并排序 \quad D. 基数排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 冒泡排序的特点是每一趟将未排序部分的最大值移动到其最终位置。\\
    2. 第一趟将 $88$ 移到最后，第二趟将 $16$ 移到倒数第二，第三趟将 $12$ 移到倒数第三，符合冒泡排序的特点。\\
    3. 希尔排序、归并排序和基数排序的排序过程与此不符。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

\item 为实现快速排序算法，待排序序列宜采用的存储方式是（ ）。\\
    【2011 年全国试题 10（2 分）】\\

    A. 顺序存储 \quad B. 散列存储 \quad C. 链式存储 \quad D. 索引存储 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 快速排序需要频繁访问和交换元素，顺序存储能够提供高效的随机访问。\\
    2. 链式存储不适合快速排序，因为其随机访问效率较低。\\
    3. 散列存储和索引存储不适用于快速排序。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

\item 已知序列 $\{25, 13, 10, 12, 9\}$ 是大根堆，在序列尾部插入新元素 18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是（ ）。\\
    【2011 年全国试题 11（2 分）】\\

    A. 1 \quad B. 2 \quad C. 4 \quad D. 5 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 插入新元素 18 后，将其放在堆的末尾，然后向上调整。\\
    2. 调整过程中需要与父节点进行比较，最多需要 2 次比较：\\
       - 第一次与父节点 $10$ 比较，交换位置；\\
       - 第二次与新的父节点 $25$ 比较，不再交换。\\
    3. 因此，答案为 \textcolor{red}{B}。\\

\item 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。下列排序方法中，每一趟排序结束时都至少能够确定一个元素最终位置的方法是（ ）。\\
    【2012 年全国试题 10（2 分）】\\

    I. 简单选择排序 \\  
    II. 希尔排序 \\  
    III. 快速排序 \\  
    IV. 堆排序 \\  
    V. 二路归并排序 \\  

    A. 仅 I、III、 IV \quad B. 仅 I、III、V \quad C. 仅 II、III、IV \quad D. 仅 III、IV、V \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 简单选择排序、快速排序和堆排序每一趟都能确定一个元素的最终位置：\\
       - 简单选择排序每趟选出最小（或最大）元素放到最终位置；\\
       - 快速排序每趟将基准元素放到最终位置；\\
       - 堆排序每趟将堆顶元素放到最终位置。\\
    2. 希尔排序和二路归并排序不满足此条件。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是（ ）。\\
    【2012 年全国试题 11（2 分）】\\

    A. 排序的总趟数 \\  
    B. 元素的移动次数 \\  
    C. 使用辅助空间的数量 \\  
    D. 元素之间的比较次数 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 折半插入排序通过折半查找减少了比较次数，但移动次数与直接插入排序相同。\\
    2. 因此，两者的不同之处在于元素之间的比较次数。\\
    3. 因此，答案为 \textcolor{red}{D}。\\
    \item 对给定的关键字序列 $\{110, 119, 007, 911, 114, 120, 122\}$ 进行基数排序，则第二趟分配收集后得到的关键字序列是（ ）。\\
    【2013 年全国试题 11（2 分）】\\

    A. $007, 110, 119, 114, 911, 120, 122$ \\  
    B. $007, 110, 119, 114, 911, 122, 120$ \\  
    C. $007, 110, 911, 114, 119, 120, 122$ \\  
    D. $110, 120, 911, 122, 114, 007, 119$ \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 基数排序按位分配收集，第一趟按个位排序，第二趟按十位排序，最后一趟按百位排序。\\
    2. 初始序列为 $\{110, 119, 007, 911, 114, 120, 122\}$。\\
    3. 第一趟按个位排序后，序列为：$\{110, 120, 911, 122, 007, 119, 114\}$。\\
    4. 第二趟按十位排序后，序列为：$\{007, 110, 119, 114, 911, 120, 122\}$。\\
    5. 因此，答案为 \textcolor{red}{A}。\\ 

    \item 用希尔排序方法对一个数据序列进行排序时，若第一趟排序结果为 $\{9, 1, 4, 13, 7, 8, 20, 23, 15\}$，则该趟排序采用的增量（间隔）可能是（ ）。\\
    【2014 年全国试题 10（2 分）】\\

    A. 2 \quad B. 3 \quad C. 4 \quad D. 5 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 希尔排序的增量决定了分组方式，第一趟排序结果表明数据被分为若干组。\\
    2. 根据第一趟排序结果 $\{9, 1, 4, 13, 7, 8, 20, 23, 15\}$，可以推测数据被分为 4 组：\\
       - 第 1 组：$\{9, 7\}$\\
       - 第 2 组：$\{1, 8\}$\\
       - 第 3 组：$\{4, 20\}$\\
       - 第 4 组：$\{13, 23, 15\}$\\
    3. 每组内分别进行直接插入排序后，得到第一趟排序结果。\\
    4. 因此，增量（间隔）可能是 \textcolor{red}{4}。\\
    \item 下列选项中，不可能是快速排序第二趟排序结果的是（ ）。\\
    【2014 年全国试题 11（2 分）】\\

    A. $2, 3, 5, 4, 6, 7, 9$ \\  
    B. $2, 7, 5, 6, 4, 3, 9$ \\  
    C. $3, 2, 5, 4, 7, 6, 9$ \\  
    D. $4, 2, 3, 5, 7, 6, 9$ \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 快速排序的每一趟排序会将一个基准元素放到其最终位置，并将序列分为两部分。\\
    2. 假设第一趟排序选择 $9$ 为基准，第一趟排序后，序列可能为：$2, 3, 5, 4, 6, 7, 9$。\\
    3. 第二趟排序中，左部分（$2, 3, 5, 4, 6, 7$）选择 $7$ 为基准，排序后可能为：$2, 3, 5, 4, 6, 7$。\\
    4. 选项 B 中，$7$ 出现在基准 $9$ 的右侧，不符合快速排序的分区规则，因此不可能是第二趟排序结果。\\
    5. 因此，答案为 \textcolor{red}{B}。\\

    \item 下列排序算法中，元素的移动次数和关键字的初始排列次序无关的是（ ）。\\
    【2015 年全国试题 9（2 分）】\\

    A. 直接插入排序 \quad B. 冒泡排序 \quad C. 基数排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 基数排序是一种非比较排序算法，它通过多趟分配和收集操作对数据进行排序，元素的移动次数与关键字的初始排列次序无关。\\
    2. 直接插入排序和冒泡排序的移动次数与初始排列次序密切相关，初始序列越接近有序，移动次数越少。\\
    3. 快速排序的移动次数也与初始排列次序有关，最坏情况下（完全有序或逆序）会导致较多的移动操作。\\
    4. 因此，答案为 \textcolor{red}{C}。\\ 
    \item 已知小根堆为 $\{8, 15, 10, 21, 34, 16, 12\}$，删除关键字 8 之后需重建堆，在此过程中，关键字之间的比较次数是（ ）。\\
    【2015 年全国试题 10（2 分）】\\

    A. 1 \quad B. 2 \quad C. 3 \quad D. 4 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 删除堆顶元素 $8$ 后，将堆尾元素 $12$ 移到堆顶位置，堆变为 $\{12, 15, 10, 21, 34, 16\}$。\\
    2. 从堆顶开始向下调整：\\
       - 第一次比较：$12$ 与其左右子节点 $15$ 和 $10$ 比较，$10$ 最小，交换 $12$ 和 $10$，堆变为 $\{10, 15, 12, 21, 34, 16\}$。\\
       - 第二次比较：$12$ 与其左右子节点 $16$ 和无子节点比较，无需交换，调整结束。\\
    3. 共进行了 2 次比较。\\
    4. 因此，答案为 \textcolor{red}{C}。\\  

    \item 希尔排序的组内排序采用的是（ ）。\\
    【2015 年全国试题 11（2 分）】\\

    A. 直接插入排序 \quad B. 折半插入排序 \quad C. 快速排序 \quad D. 归并排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 希尔排序是一种分组插入排序算法，其组内排序采用的是直接插入排序。\\
    2. 在希尔排序中，数据根据增量（间隔）被分成若干组，每组内使用直接插入排序进行排序。\\
    3. 折半插入排序、快速排序和归并排序并不是希尔排序的组内排序方法。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

    \item 排序算法的稳定性是指（ ）。\\
    【北京理工大学 2005 一、10（1 分）】\\

    A. 经过排序之后，能使值相同的数据保持原顺序中的相对位置不变 \\  
    B. 经过排序之后，能使值相同的数据保持原顺序中的绝对位置不变 \\  
    C. 算法的排序性能与被排序元素的数量关系不大 \\  
    D. 算法的排序性能与被排序元素的数量关系密切 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 排序算法的稳定性是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 稳定性是排序算法的一种重要特性，尤其在需要多关键字排序时，稳定性可以保证次关键字的顺序不被破坏。\\
    3. 选项 A 正确描述了排序算法的稳定性定义。\\
    4. 选项 B 错误，排序算法只保证相对位置不变，而非绝对位置。\\
    5. 选项 C 和 D 与排序算法的稳定性无关。\\
    6. 因此，答案为 \textcolor{red}{A}。\\ 

    \item 下面给出的四种排序法中，（ ）是稳定的排序方法。\\
    【北京航空航天大学 1999 一、10（2 分）】\\

    A. 插入排序 \quad B. 冒泡排序 \quad C. 二路归并排序 \quad D. 堆排序 \\

    答案: \textcolor{red}{A, B, C} \\

    解析：\\
    1. 稳定的排序方法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 插入排序、冒泡排序和二路归并排序都是稳定的排序方法，因为它们不会改变相同元素的相对顺序。\\
    3. 堆排序是不稳定的排序方法，因为在调整堆的过程中，相同元素的相对顺序可能会被打乱。\\
    4. 因此，答案为 \textcolor{red}{A, B, C}。\\

    \item 下列排序算法中，（ ）是稳定的。\\
    【福州大学 1998 一、3（2 分）】\\

    A. 堆排序，冒泡排序 \\  
    B. 快速排序，堆排序 \\  
    C. 直接选择排序，归并排序 \\  
    D. 归并排序，冒泡排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 冒泡排序和归并排序是稳定的排序算法，因为它们不会改变相同元素的相对顺序。\\
    3. 堆排序和快速排序是不稳定的排序算法，因为在调整堆或分区的过程中，相同元素的相对顺序可能会被打乱。\\
    4. 直接选择排序也是不稳定的排序算法，因为在选择最小（或最大）元素时可能会改变相同元素的相对顺序。\\
    5. 因此，答案为 \textcolor{red}{D}。\\

    \item 稳定的排序方法是（ ）。\\
    【北方交通大学 2000 二、3（2 分）】\\

    A. 直接插入排序和快速排序 \\  
    B. 折半插入排序和冒泡排序 \\  
    C. 简单选择排序和四路归并排序 \\  
    D. 树形选择排序和 Shell 排序 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 稳定的排序方法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 直接插入排序和冒泡排序是稳定的排序方法，因为它们不会改变相同元素的相对顺序。\\
    3. 快速排序、简单选择排序、四路归并排序、树形选择排序和 Shell 排序均为不稳定的排序方法，因为在排序过程中可能会打乱相同元素的相对顺序。\\
    4. 因此，答案为 \textcolor{red}{B}。\\

    \item 下列排序方法中，哪一个是稳定的排序方法（ ）。\\
    【北方交通大学 2001 一、8（2 分）】\\

    A. 直接选择排序 \quad B. 二分法插入排序 \quad C. 希尔排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 稳定的排序方法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 二分法插入排序是稳定的排序方法，因为它不会改变相同元素的相对顺序。\\
    3. 直接选择排序、希尔排序和快速排序均为不稳定的排序方法，因为在排序过程中可能会打乱相同元素的相对顺序。\\
    4. 因此，答案为 \textcolor{red}{B}。\\
    \item 下列排序算法中，（ ）是稳定排序。\\
    【北京理工大学 2007 一、10（1 分）】\\

    A. 希尔排序 \quad B. 快速排序 \quad C. 堆排序 \quad D. 直接插入排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 直接插入排序是稳定的排序算法，因为它不会改变相同元素的相对顺序。\\
    3. 希尔排序、快速排序和堆排序均为不稳定的排序算法，因为在排序过程中可能会打乱相同元素的相对顺序。\\
    4. 因此，答案为 \textcolor{red}{D}。\\ 

    \item 如果待排序序列中两个数据元素具有相同的值，在排序前后它们的相互位置发生颠倒，则称该排序算法是不稳定的。（ ）就是不稳定的排序方法。\\
    【清华大学 1998 一、3（2 分）】\\

    A. 冒泡排序 \quad B. 归并排序 \quad C. Shell 排序 \quad D. 直接插入排序 \quad E. 简单选择排序 \\

    答案: \textcolor{red}{C, E} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 冒泡排序和直接插入排序是稳定的排序算法，因为它们不会改变相同元素的相对顺序。\\
    3. Shell 排序和简单选择排序是不稳定的排序算法，因为在分组或选择过程中可能会打乱相同元素的相对顺序。\\
    4. 归并排序是稳定的排序算法，因为它在归并过程中不会改变相同元素的相对顺序。\\
    5. 因此，答案为 \textcolor{red}{C, E}。\\ 

    \item 若要求排序是稳定的，且关键字为实数，则在下列排序方法中应选（ ）排序为宜。\\
    【中科院计算所 2000 一、5（2 分）】\\

    A. 直接插入排序 \quad B. 直接选择排序 \quad C. 堆排序 \quad D. 快速排序 \quad E. 基数排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 直接插入排序是稳定的排序算法，且适用于关键字为实数的情况。\\
    3. 基数排序虽然是稳定的，但通常用于整数或字符串排序，不适合直接处理实数。\\
    4. 直接选择排序、堆排序和快速排序均为不稳定的排序算法，不满足题目要求。\\
    5. 因此，答案为 \textcolor{red}{A}。\\

    \item 若需在 $O(n \log n)$ 的时间内完成对数组的排序，且要求排序是稳定的，则可选择的排序方法是（ ）。\\
    【中国科技大学 1998 二、4（2 分）；中科院计算所 1998 二、4（2 分）】\\

    A. 快速排序 \quad B. 堆排序 \quad C. 归并排序 \quad D. 直接插入排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 快速排序和堆排序均为不稳定的排序算法，因此不符合题目要求。\\
    3. 直接插入排序是稳定的排序算法，但其时间复杂度为 $O(n^2)$，不满足 $O(n \log n)$ 的时间要求。\\
    4. 归并排序是稳定的排序算法，且其时间复杂度为 $O(n \log n)$，符合题目要求。\\
    5. 因此，答案为 \textcolor{red}{C}。\\  

    \item 下面的排序算法中，不稳定的是（ ）。\\
    【北京工业大学 1999 一、2（2 分）】\\

    A. 冒泡排序 \quad B. 折半插入排序 \quad C. 简单选择排序 \quad D. 希尔排序 \\  
    E. 基数排序 \quad F. 堆排序 \\

    答案: \textcolor{red}{B, C, D, F} \\

    解析：\\
    1. 稳定的排序算法是指在排序过程中，若两个元素的值相同，则排序后它们的相对顺序保持不变。\\
    2. 冒泡排序和基数排序是稳定的排序算法，因为它们不会改变相同元素的相对顺序。\\
    3. 折半插入排序、简单选择排序、希尔排序和堆排序是不稳定的排序算法，因为在排序过程中可能会打乱相同元素的相对顺序。\\
    4. 因此，答案为 \textcolor{red}{B, C, D, F}。\\

    \item 下列内部排序算法中：\\
    A. 快速排序 \quad B. 直接插入排序 \quad C. 二路归并排序 \quad D. 简单选择排序 \\  
    E. 冒泡排序 \quad F. 堆排序 \\

    (1) 其比较次数与序列初态无关的算法是（ ）。 \\  
    答案: \textcolor{red}{C, F} \\  
    解析：\\
    1. 二路归并排序和堆排序的比较次数与序列初态无关，因为它们的比较次数仅与数据规模有关。\\
    2. 快速排序、直接插入排序、简单选择排序和冒泡排序的比较次数与初态密切相关。\\

    (2) 不稳定的排序算法是（ ）。 \\  
    答案: \textcolor{red}{A, D, F} \\  
    解析：\\
    1. 快速排序、简单选择排序和堆排序是不稳定的排序算法，因为它们可能会打乱相同元素的相对顺序。\\
    2. 二路归并排序、直接插入排序和冒泡排序是稳定的排序算法。\\

    (3) 在初始序列已基本有序（除去 $k$ 个元素中的某 $k$ 个元素后即呈有序，$k < n$）的情况下，排序效率最高的算法是（ ）。 \\  
    答案: \textcolor{red}{B} \\  
    解析：\\
    1. 直接插入排序在初始序列基本有序时效率最高，其时间复杂度接近 $O(n)$。\\
    2. 其他排序算法在这种情况下效率不如直接插入排序。\\

    (4) 排序的平均时间复杂度为 $O(n \log n)$ 的算法是（ ），为 $O(n^2)$ 的算法是（ ）。 \\  
    答案: \textcolor{red}{A, C, F；B, D, E} \\  
    解析：\\
    1. 快速排序、二路归并排序和堆排序的平均时间复杂度为 $O(n \log n)$。\\
    2. 直接插入排序、简单选择排序和冒泡排序的平均时间复杂度为 $O(n^2)$。\\ 

    \item 排序趟数与序列的原始状态有关的排序方法是（ ）排序法。\\
    【北京航空航天大学 1999 一、5（2 分）】\\

    A. 插入排序 \quad B. 选择排序 \quad C. 冒泡排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{A, C, D} \\

    解析：\\
    1. 插入排序、冒泡排序和快速排序的排序趟数与序列的原始状态密切相关：\\
       - 插入排序在序列接近有序时效率较高，趟数较少；\\
       - 冒泡排序在序列接近有序时，交换次数和趟数会减少；\\
       - 快速排序在序列接近有序时，分区效率较低，可能增加趟数。\\
    2. 选择排序的排序趟数与序列的原始状态无关，每次都需要扫描整个未排序部分以找到最小（或最大）值。\\
    3. 因此，答案为 \textcolor{red}{A, C, D}。\\

    \item 下面给出的四种排序方法中，排序过程中的比较次数与排序方法无关的是（ ）。\\
    【北京航空航天大学 2000 一、10（2 分）】\\

    A. 选择排序法 \quad B. 插入排序法 \quad C. 快速排序法 \quad D. 堆排序法 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 选择排序法的比较次数与序列的初始状态无关，因为每一趟都需要扫描整个未排序部分以找到最小（或最大）值。\\
    2. 插入排序法和快速排序法的比较次数与序列的初始状态密切相关，初始序列越接近有序，比较次数越少。\\
    3. 堆排序法的比较次数也与序列的初始状态无关，因为堆的调整过程仅与数据规模有关。\\
    4. 因此，答案为 \textcolor{red}{A}。\\  

    \item 排序方法中，关键字比较的次数与记录的初始排列无关的是（ ）。\\
    【北京交通大学 2013 二、14（2 分）】\\

    A. 简单选择排序 \quad B. 快速排序 \quad C. 直接插入排序 \quad D. Shell 排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 简单选择排序的关键字比较次数与记录的初始排列无关，因为每一趟都需要扫描整个未排序部分以找到最小（或最大）值。\\
    2. 快速排序、直接插入排序和 Shell 排序的关键字比较次数与记录的初始排列密切相关，初始序列越接近有序，比较次数越少。\\
    3. 因此，答案为 \textcolor{red}{A}。\\  

    \item 对下列四种排序方法，在排序中关键字比较次数同记录初始排列无关的是（ ）。\\
    【南京理工大学 2000 一、7（1.5 分）】\\

    A. 直接插入排序 \quad B. 二分法插入排序 \quad C. 快速排序 \quad D. 归并排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 归并排序的关键字比较次数与记录的初始排列无关，因为归并排序的比较次数仅与数据规模有关，按照固定的分治策略进行。\\
    2. 直接插入排序和二分法插入排序的比较次数与初始排列密切相关，初始序列越接近有序，比较次数越少。\\
    3. 快速排序的比较次数也与初始排列相关，最坏情况下（完全有序或逆序）会导致较多的比较次数。\\
    4. 因此，答案为 \textcolor{red}{D}。\\ 

    \item 在下列排序算法中，哪一个算法的时间复杂度与初始排序无关（ ）。\\
    【北京理工大学 2001 六、4（2 分）；北京工业大学 2005 一、4（2 分）】\\

    A. 直接插入排序 \quad B. 冒泡排序 \quad C. 快速排序 \quad D. 直接选择排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 直接选择排序的时间复杂度与初始排序无关，因为每一趟都需要扫描整个未排序部分以找到最小（或最大）值，比较次数固定为 $O(n^2)$。\\
    2. 直接插入排序和冒泡排序的时间复杂度与初始排序密切相关，初始序列越接近有序，时间复杂度越低。\\
    3. 快速排序的时间复杂度也与初始排序相关，最坏情况下（完全有序或逆序）时间复杂度为 $O(n^2)$。\\
    4. 因此，答案为 \textcolor{red}{D}。\\  

    \item 下述几种排序方法中，要求内存量最大的是（ ）。\\
    【中南大学 2005 一、6（2 分）】\\

    A. 归并排序 \quad B. 快速排序 \quad C. 插入排序 \quad D. 选择排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 归并排序需要额外的辅助数组来存储归并过程中的中间结果，其空间复杂度为 $O(n)$，因此需要的内存量最大。\\
    2. 快速排序的空间复杂度为 $O(\log n)$，主要用于递归调用栈。\\
    3. 插入排序和选择排序是原地排序算法，空间复杂度为 $O(1)$，不需要额外的内存。\\
    4. 因此，答案为 \textcolor{red}{A}。\\ 

    \item 快速排序方法在（ ）情况下最不利于发挥其长处。\\
    【华南理工大学 2007】\\

    A. 要排序的数据量太大 \\  
    B. 要排序的数据中含有多个相同值 \\  
    C. 要排序的数据个数为奇数 \\  
    D. 要排序的数据已基本有序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 快速排序的性能与基准元素的选择密切相关，理想情况下基准元素能将序列均匀分割。\\
    2. 当数据已基本有序时，快速排序的分区会非常不均匀，导致递归深度增加，时间复杂度退化为 $O(n^2)$。\\
    3. 数据量太大时，快速排序仍能保持较好的性能，时间复杂度为 $O(n \log n)$。\\
    4. 数据中含有多个相同值时，可以通过优化（如三路快排）来减少重复分区的影响。\\
    5. 数据个数为奇数对快速排序的性能没有显著影响。\\
    6. 因此，答案为 \textcolor{red}{D}。\\

    \item 当待排序列基本有序时，下列排序方法中（ ）最好。\\
    【北京邮电大学 2005 一、10（2 分）】\\

    A. 直接插入排序 \quad B. 快速排序 \quad C. 堆排序 \quad D. 归并排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 直接插入排序在初始序列基本有序时效率最高，其时间复杂度接近 $O(n)$，因为每次插入时只需少量比较和移动操作。\\
    2. 快速排序在基本有序的情况下可能退化为 $O(n^2)$，不适合此场景。\\
    3. 堆排序和归并排序的时间复杂度为 $O(n \log n)$，但它们不如直接插入排序在基本有序情况下高效。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

    \item 设被排序的结点序列共有 $N$ 个结点，在该序列中的结点已十分接近排序的情况下，用直接插入法、归并法和一般的快速排序法对其排序，这些算法的时间复杂性应为（ ）。\\
    【上海交通大学 2005 四、5（2 分）】\\

    A. $O(N)$，$O(N)$，$O(N)$ \\  
    B. $O(N)$，$O(N \log N)$，$O(N \log N)$ \\  
    C. $O(N)$，$O(N \log N)$，$O(N^2)$ \\  
    D. $O(N^2)$，$O(N^2 \log N)$，$O(N^2)$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 直接插入排序在序列已十分接近排序的情况下效率最高，其时间复杂度为 $O(N)$。\\
    2. 归并排序的时间复杂度与序列的初始状态无关，始终为 $O(N \log N)$。\\
    3. 一般的快速排序法在序列已十分接近排序的情况下，分区会非常不均匀，导致时间复杂度退化为 $O(N^2)$。\\
    4. 因此，答案为 \textcolor{red}{C}。\\

    \item 数据序列 $\{8, 9, 10, 4, 5, 6, 20, 1, 2\}$ 只能是下列排序算法中的（ ）的两趟排序后的结果。\\
    【合肥工业大学 1999 一、3（2 分）】\\

    A. 选择排序 \quad B. 冒泡排序 \quad C. 插入排序 \quad D. 堆排序 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 冒泡排序的特点是每一趟将未排序部分的最大值移动到其最终位置。\\
    2. 第一趟排序后，最大值 $20$ 被移动到最后，序列变为 $\{8, 9, 10, 4, 5, 6, 1, 2, 20\}$。\\
    3. 第二趟排序后，次大值 $10$ 被移动到倒数第二位，序列变为 $\{8, 9, 4, 5, 6, 1, 2, 10, 20\}$。\\
    4. 选择排序和插入排序的排序过程与此结果不符，堆排序的调整过程也不符合此序列变化。\\
    5. 因此，答案为 \textcolor{red}{B}。\\  

    \item 一个排序算法的时间复杂度与（ ）有关。\\
    【华中科技大学 2004 一、8（1 分）】\\

    A. 排序算法的稳定性 \\  
    B. 所需比较关键字的次数 \\  
    C. 所采用的存储结构 \\  
    D. 所需辅助存储空间的大小 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 排序算法的时间复杂度主要由关键字的比较次数和记录的移动次数决定。\\
    2. 排序算法的稳定性与时间复杂度无直接关系。\\
    3. 存储结构和辅助存储空间的大小主要影响排序算法的空间复杂度，而非时间复杂度。\\
    4. 因此，答案为 \textcolor{red}{B}。\\

    \item 对一组数据 $\{84, 47, 25, 15, 21\}$ 排序，数据的排列次序在排序的过程中的变化为：\\
    
    (1) $84, 47, 25, 15, 21$ \\  
    (2) $15, 47, 25, 84, 21$ \\  
    (3) $15, 21, 25, 84, 47$ \\  
    (4) $15, 21, 25, 47, 84$ \\  

    则采用的排序是（ ）。\\
    【南京理工大学 1997 一、2（2 分）】\\  

    A. 选择排序 \quad B. 冒泡排序 \quad C. 快速排序 \quad D. 插入排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 选择排序的特点是每一趟从未排序部分中选出最小值，放到已排序部分的末尾。\\
    2. 第一次选择 $15$，放到第一个位置，序列变为 $15, 47, 25, 84, 21$。\\
    3. 第二次选择 $21$，放到第二个位置，序列变为 $15, 21, 25, 84, 47$。\\
    4. 第三次选择 $25$，放到第三个位置，序列变为 $15, 21, 25, 47, 84$。\\
    5. 冒泡排序和插入排序的排序过程与此结果不符，快速排序的分区过程也不符合此序列变化。\\
    6. 因此，答案为 \textcolor{red}{A}。\\

    \item 对序列 $\{15, 9, 7, 8, 20, -1, 4\}$ 进行排序，进行一趟后数据的排列变为 $\{4, 9, -1, 8, 20, 7, 15\}$，则采用的是（ ）排序。\\
    【南京理工大学 1998 一、8（2 分）】\\  

    A. 选择排序 \quad B. 快速排序 \quad C. 希尔排序 \quad D. 冒泡排序 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 快速排序的特点是每一趟排序会选择一个基准元素，将序列分为两部分：左侧小于基准，右侧大于基准。\\
    2. 在本题中，基准元素可能是 $15$，经过一趟排序后，序列变为 $\{4, 9, -1, 8, 20, 7, 15\}$，符合快速排序的分区规则。\\
    3. 选择排序、希尔排序和冒泡排序的排序过程与此结果不符。\\
    4. 因此，答案为 \textcolor{red}{B}。\\

    \item 若上题的数据经第二趟排序后的排列为 $\{9, 15, 7, 8, 20, -1, 4\}$，则采用的是（ ）排序。\\
    【南京理工大学 1998 一、9（2 分）】 \\

    A. 选择排序 \quad B. 快速排序 \quad C. 直接插入排序 \quad D. 冒泡排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 直接插入排序的特点是每次将一个元素插入到已排序部分的合适位置。\\
    2. 第一趟排序后，$15$ 被插入到合适位置，序列变为 $\{9, 15, 7, 8, 20, -1, 4\}$。\\
    3. 第二趟排序后，$7$ 被插入到合适位置，序列仍为 $\{9, 15, 7, 8, 20, -1, 4\}$，符合直接插入排序的过程。\\
    4. 选择排序、快速排序和冒泡排序的排序过程与此结果不符。\\
    5. 因此，答案为 \textcolor{red}{C}。\\

    \item （ ）占用的额外空间的空间复杂性为 $O(1)$。\\
    【上海交通大学 2005 四、4（2 分）】\\  

    A. 堆排序算法 \quad B. 归并排序算法 \quad C. 快速排序算法 \quad D. 以上答案都不对 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 堆排序是一种原地排序算法，其空间复杂度为 $O(1)$，因为它只需要常量级的额外空间来进行堆的调整。\\
    2. 归并排序需要额外的辅助数组来存储归并过程中的中间结果，其空间复杂度为 $O(n)$。\\
    3. 快速排序在递归调用时需要栈空间，其空间复杂度为 $O(\log n)$。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

    \item 有些排序算法在每趟排序过程中都会有一个元素被放置在其最终的位置上，以下不全出现此情况的是（ ）。\\
    【北京交通大学 2005 一、7（2 分）】\\  

    A. Shell 排序 \quad B. 堆排序 \quad C. 冒泡排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. Shell 排序（希尔排序）是分组排序，每趟排序并不一定能确定某个元素的最终位置。\\
    2. 堆排序每趟将堆顶元素（最大或最小）放到其最终位置。\\
    3. 冒泡排序每趟将未排序部分的最大或最小值移动到其最终位置。\\
    4. 快速排序每趟将基准元素放到其最终位置。\\
    5. 因此，答案为 \textcolor{red}{A}。\\ 

    \item 下列排序算法中，（ ）排序在一趟结束后不一定能选出一个元素放在其最终位置上。\\
    【南京理工大学 2005 一、10（1 分）；哈尔滨工业大学 2001 二、4（2 分）】\\  

    A. 希尔排序 \quad B. 冒泡排序 \quad C. 选择排序 \quad D. 直接插入排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 希尔排序是一种分组排序算法，每趟排序是对分组内的元素进行排序，不能保证某个元素在一趟结束后就放在其最终位置上。\\
    2. 冒泡排序每趟会将未排序部分的最大或最小值移动到其最终位置。\\
    3. 选择排序每趟会选出未排序部分的最小或最大值并放到其最终位置。\\
    4. 直接插入排序每次插入一个元素到已排序部分，逐步确定元素的位置。\\
    5. 因此，答案为 \textcolor{red}{A}。\\

    \item 下列排序算法中，某一趟结束后未必能选出一个元素放在其最终位置上的是（ ）。\\
    【吉林大学 2016 一、4（2 分）】 \\

    A. 堆排序 \quad B. 冒泡排序 \quad C. 分划交换排序 \quad D. 直接插入排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 分划交换排序（即快速排序）在每一趟结束后，只有基准元素被放置在其最终位置上，其他元素未必确定最终位置。\\
    2. 堆排序每一趟会将堆顶元素（最大或最小值）放置在其最终位置。\\
    3. 冒泡排序每一趟会将未排序部分的最大或最小值移动到其最终位置。\\
    4. 直接插入排序每次插入一个元素到已排序部分，逐步确定元素的位置。\\
    5. 因此，答案为 \textcolor{red}{C}。\\ 

    \item （多选）在下列排序方法中，（ ）等方法在每趟结束后，选出一个元素到最终的位置。\\
    【华中科技大学 2007 二、18（2 分）】\\  

    A. 选择排序 \quad B. 归并排序 \quad C. 冒泡排序 \quad D. 堆排序 \\

    答案: \textcolor{red}{A, C, D} \\

    解析：\\
    1. 选择排序每一趟从未排序部分中选出最小（或最大）元素，放到其最终位置。\\
    2. 冒泡排序每一趟将未排序部分的最大（或最小）值移动到其最终位置。\\
    3. 堆排序每一趟将堆顶元素（最大或最小值）放到其最终位置。\\
    4. 归并排序是分治法，每趟归并并不能确定某个元素的最终位置。\\
    5. 因此，答案为 \textcolor{red}{A, C, D}。\\

    \item 下列序列中，（ ）是执行第一趟快速排序后所得的序列。  
    【福州大学 1998 一、9（2 分）】 

    A. $\{68, 11, 18, 69, 23, 93, 73\}$  

    B. $\{68, 11, 69, 23, 18, 93, 73\}$ 

    C. $\{93, 73, 68, 11, 69, 23, 18\}$  

    D. $\{68, 11, 69, 23, 18, 93, 73\}$  

    答案: \textcolor{red}{C} \\
    解析：\\
    1. 快速排序的第一趟排序会选择一个基准元素（通常是第一个元素），将序列分为两部分：左侧小于基准，右侧大于基准。\\
    2. 在选定基准元素后，经过一趟排序，基准元素会被放置在其最终位置上。\\
    3.而这里并没有告诉我们初始序列，所以我只需要去选项中找到满足可以将序列分为两部分的即可。\\
    4.只有选项C，93作为枢纽，右侧均小于它。
    \item 适合并行处理的排序算法是（ ）。\\
    【西安电子科技大学 2005 一、8（1 分）】\\  

    A. 选择排序 \quad B. 快速排序 \quad C. 希尔排序 \quad D. 基数排序 \\

    答案: \textcolor{red}{B, D} \\

    解析：\\
    1. 快速排序可以通过并行化处理左右两个分区，从而提高效率，因此适合并行处理。\\
    2. 基数排序可以将不同位的排序任务分配到多个处理器上并行执行，因此也适合并行处理。\\
    3. 选择排序和希尔排序的操作步骤较难并行化，不适合并行处理。\\
    4. 因此，答案为 \textcolor{red}{B, D}。\\ 

    \item 一组记录的关键字为 $\{46, 79, 56, 38, 40, 84\}$，则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（ ）。\\
    【北京交通大学 2005 一、8（2 分）；燕山大学 2001 一、4（2 分）】 \\

    A. $\{38, 40, 46, 56, 79, 84\}$ \\  
    B. $\{40, 38, 46, 79, 56, 84\}$ \\  
    C. $\{40, 38, 46, 56, 79, 84\}$ \\  
    D. $\{40, 38, 46, 84, 56, 79\}$ \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 快速排序的第一趟排序会选择第一个记录 $46$ 作为基准，将序列分为两部分：左侧小于基准，右侧大于基准。\\
    2. 根据题目，经过一次划分后，左侧为 $\{40, 38\}$，右侧为 $\{56, 79, 84\}$，基准 $46$ 位于中间。\\
    3. 选项 C 中的序列 $\{40, 38, 46, 56, 79, 84\}$ 符合快速排序的分区规则。\\
    4. 因此，答案为 \textcolor{red}{C}。\\
    \item 下列排序算法中，（ ）算法可能会出现下面的情况：初始数据有序时，花费的时间反而最多。\\
    【中南大学 2005 一、4（2 分）】\\  

    A. 快速排序 \quad B. 堆排序 \quad C. 希尔排序 \quad D. 冒泡排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 快速排序在初始数据有序时，若基准元素选择不当（如总是选择第一个或最后一个元素），会导致分区极不均匀，时间复杂度退化为 $O(n^2)$。\\
    2. 冒泡排序在初始数据有序时，不需要交换，因此花费的时间较少。\\
    3. 堆排序和希尔排序的性能与初始数据的有序性无关，因此不会因为初始数据有序而花费更多时间。\\
    4. 因此，答案为 \textcolor{red}{A, D}。\\

    \item 将一组无序的数据重新排列成有序序列，其方法有（ ）。\\
    【武汉理工大学 2004 一、8（3 分）】\\  

    A. 拓扑排序 \quad B. 快速排序 \quad C. 堆排序 \quad D. 基数排序 \\

    答案: \textcolor{red}{B, C, D} \\

    解析：\\
    1. 快速排序、堆排序和基数排序都是常用的排序算法，可以将无序数据重新排列成有序序列。\\
    2. 拓扑排序是一种用于有向无环图的排序方法，主要用于解决依赖关系问题，不适用于一般的排序任务。\\
    3. 因此，答案为 \textcolor{red}{B, C, D}。\\
    \item 就平均性能而言，目前最好的内排序方法是（ ）排序法。\\
    【西安电子科技大学 1998 一、9（2 分）】\\  

    A. 冒泡排序 \quad B. 希尔插入排序 \quad C. 交换排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 快速排序在平均情况下的时间复杂度为 $O(n \log n)$，是目前最好的内排序方法之一。\\
    2. 冒泡排序和交换排序的时间复杂度为 $O(n^2)$，性能较差。\\
    3. 希尔插入排序的性能优于冒泡排序，但其时间复杂度依赖于增量序列，平均性能不如快速排序。\\
    4. 因此，答案为 \textcolor{red}{D}。\\

    \item 如果只想得到 1000 个元素组成的序列中第 5 个最小元素之前的部分排序的序列，用（ ）方法最快。\\
    【清华大学 1998 一、2（2 分）】 \\

    A. 冒泡排序 \quad B. 快速排序 \quad C. Shell 排序 \quad D. 堆排序 \quad E. 简单选择排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 堆排序特别适合用于部分排序问题，例如找到前 $k$ 个最小元素。\\
    2. 使用堆排序可以构建一个大小为 $k$ 的小根堆或大根堆，仅需对前 $k$ 个元素进行调整，效率较高。\\
    3. 快速排序虽然效率高，但需要对整个序列进行分区，不如堆排序高效。\\
    4. 冒泡排序、Shell 排序和简单选择排序的效率较低，不适合处理部分排序问题。\\
    5. 因此，答案为 \textcolor{red}{D}。\\

    \item 若要从 1000 个元素中选出前 10 个最小的元素，（ ）是最适合的算法。\\
    【北京理工大学 2005 一、9（1 分）】 \\

    A. 直接插入排序 \quad B. 归并排序 \quad C. 堆排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 堆排序特别适合用于部分排序问题，例如找到前 $k$ 个最小元素。\\
    2. 使用堆排序可以构建一个大小为 $k$ 的小根堆，仅需对前 $k$ 个元素进行调整，效率较高。\\
    3. 快速排序和归并排序需要对整个序列进行排序，效率不如堆排序高效。\\
    4. 直接插入排序在处理大规模数据时效率较低，不适合此场景。\\
    5. 因此，答案为 \textcolor{red}{C}。\\
    \item 对数据序列 $\{8, 9, 10, 4, 5, 6, 20, 1, 2\}$ 采用（由后向前次序的）冒泡排序，需要进行的趟数（轮数）至少是（ ）。\\
    【中国科学技术大学 2005】 \\

    A. 3 \quad B. 4 \quad C. 5 \quad D. 8 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 冒泡排序的特点是每一趟将未排序部分的最大值移动到其最终位置。\\
    2. 由后向前次序的冒泡排序中，每一趟从序列末尾开始比较并交换相邻元素，直到序列前部。\\
    3. 初始序列 $\{8, 9, 10, 4, 5, 6, 20, 1, 2\}$ 中，最大值 $20$ 已在正确位置，因此不需要移动。\\
    4. 剩余序列 $\{8, 9, 10, 4, 5, 6, 1, 2\}$ 需要至少 5 趟排序才能完全有序。\\
    5. 因此，答案为 \textcolor{red}{C}。\\ 

    \item 下列排序算法中，占用辅助空间最多的是（ ）。\\
    【厦门大学 2002 五、2（8 分）】 \\

    A. 归并排序 \quad B. 快速排序 \quad C. 希尔排序 \quad D. 堆排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 归并排序需要额外的辅助数组来存储归并过程中的中间结果，其空间复杂度为 $O(n)$，占用的辅助空间最多。\\
    2. 快速排序的空间复杂度为 $O(\log n)$，主要用于递归调用栈。\\
    3. 希尔排序和堆排序是原地排序算法，空间复杂度为 $O(1)$，不需要额外的辅助空间。\\
    4. 因此，答案为 \textcolor{red}{A}。\\
    \item 在下面的排序方法中，辅助空间为 $O(n)$ 的是（ ）。\\
    【南京理工大学 1999 一、17（1 分）】 \\

    A. 希尔排序 \quad B. 堆排序 \quad C. 选择排序 \quad D. 归并排序 \\

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 归并排序需要额外的辅助数组来存储归并过程中的中间结果，其空间复杂度为 $O(n)$。\\
    2. 希尔排序、堆排序和选择排序是原地排序算法，空间复杂度为 $O(1)$，不需要额外的辅助空间。\\
    3. 因此，答案为 \textcolor{red}{D}。\\

    \item 从未排序序列中依次取出一个元素与已排序序列中的元素依次进行比较，然后将其放在已排序序列的合适位置，该排序方法称为（ ）排序法。\\
    【北京航空航天大学 1999 一、8（2 分）】\\  

    A. 插入排序 \quad B. 选择排序 \quad C. 希尔排序 \quad D. 二路归并排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 插入排序的特点是从未排序序列中依次取出一个元素，与已排序序列中的元素进行比较，然后插入到合适的位置。\\
    2. 选择排序是从未排序序列中选择最小（或最大）元素放到已排序部分的末尾。\\
    3. 希尔排序是分组插入排序，属于插入排序的改进版本。\\
    4. 二路归并排序是分治法，将序列分成两部分分别排序后再合并。\\
    5. 因此，答案为 \textcolor{red}{A}。\\

\item 在下列排序方法中，（ ）方法可能出现这种情况：在最后一趟开始之前，所有的元素都不在其最终应在的正确位置上。\\
    【武汉理工大学 2003 一、10（2 分）】\\  

    A. 快速排序 \quad B. 冒泡排序 \quad C. 堆排序 \quad D. 插入排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 快速排序在每一趟排序中，只能确定基准元素的位置，其他元素未必在其最终位置上。\\
    2. 冒泡排序每一趟会将未排序部分的最大或最小值移动到其最终位置。\\
    3. 堆排序每一趟会将堆顶元素（最大或最小值）放置在其最终位置。\\
    4. 插入排序逐步将元素插入到已排序部分，最终所有元素都在正确位置上。\\
    5. 因此，答案为 \textcolor{red}{A}。\\

    \item 用直接插入排序方法对下面四个序列进行排序（由小到大），元素比较次数最少的是（ ）。\\
    【北方交通大学 2001 一、15（2 分）】\\  

    A. $\{94, 32, 40, 90, 80, 46, 21, 69\}$ \\  
    B. $\{32, 40, 21, 46, 69, 94, 90, 80\}$ \\  
    C. $\{21, 32, 46, 40, 80, 69, 90, 94\}$ \\  
    D. $\{90, 69, 80, 46, 21, 32, 94, 40\}$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 直接插入排序的比较次数与序列的初始有序程度密切相关，初始序列越接近有序，比较次数越少。\\
    2. 选项 C 中的序列 $\{21, 32, 46, 40, 80, 69, 90, 94\}$ 已基本有序，仅需少量比较即可完成排序。\\
    3. 其他选项的初始序列无序程度较高，因此需要更多的比较次数。\\
    4. 因此，答案为 \textcolor{red}{C}。\\
    \item 直接插入排序在最好情况下的时间复杂度为（ ）。\\
    【北京邮电大学 1999 一、5（2 分）】\\  

    A. $O(\log n)$ \quad B. $O(n)$ \quad C. $O(n \log n)$ \quad D. $O(n^2)$ \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 在最好情况下，直接插入排序的初始序列已经有序，每次插入时只需进行一次比较即可完成。\\
    2. 因此，时间复杂度为 $O(n)$。\\

\item 在文件“局部有序”或文件长度较小的情况下，最佳内部排序的方法是（ ）。\\
    【山东大学 2001 二、2（1 分）】\\  

    A. 直接插入排序 \quad B. 冒泡排序 \quad C. 简单选择排序 \quad D. 快速排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 在文件“局部有序”或文件长度较小的情况下，直接插入排序效率最高，其时间复杂度接近 $O(n)$。\\
    2. 冒泡排序和简单选择排序效率较低，快速排序适合大规模数据排序。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 在排序算法中，每次从未排序的记录中挑出最小（或最大）关键字的记录加入到已排序记录的末尾，该排序方法是（ ）。\\
    【中山大学 1999 一、11（1 分）】\\  

    A. 选择排序 \quad B. 冒泡排序 \quad C. 插入排序 \quad D. 堆排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 选择排序的特点是每次从未排序部分中挑出最小（或最大）关键字的记录，放到已排序部分的末尾。\\
    2. 冒泡排序通过相邻元素交换实现排序，插入排序逐步插入元素，堆排序通过堆结构调整实现排序。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 若用冒泡排序方法对序列 $\{10, 14, 26, 29, 41, 52\}$ 从大到小排序，需进行（ ）次比较。\\
    【南京理工大学 1999 一、11（4 分）】\\  

    A. 3 \quad B. 10 \quad C. 15 \quad D. 25 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 冒泡排序的比较次数为 $\frac{n(n-1)}{2}$，其中 $n$ 为序列长度。\\
    2. 对于长度为 6 的序列，比较次数为 $\frac{6 \times (6-1)}{2} = 15$。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

    \item 采用简单选择排序，比较次数与移动次数分别为（ ）。\\
    【南京理工大学 2000 一、18（1.5 分）】\\  

    A. $O(n)$，$O(\log n)$ \\  
    B. $O(\log n)$，$O(n^2)$ \\  
    C. $O(n^2)$，$O(n)$ \\  
    D. $O(n \log n)$，$O(n)$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 简单选择排序的比较次数为 $O(n^2)$，因为每一趟需要扫描未排序部分以找到最小（或最大）值，总共需要进行 $\frac{n(n-1)}{2}$ 次比较。\\
    2. 移动次数为 $O(n)$，因为每一趟最多只需要一次移动操作，将选出的最小（或最大）值放到已排序部分的末尾。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

    \item 对序列 $\{15, 9, 7, 8, 20, -1, 4\}$ 用希尔排序方法排序，经一趟后序列变为 $\{15, -1, 4, 8, 20, 9, 7\}$，则该次采用的增量是（ ）。\\
    【南京理工大学 1999 一、15（1 分）】\\  

    A. 1 \quad B. 4 \quad C. 3 \quad D. 2 \\

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 希尔排序的增量决定了分组方式。\\
    2. 根据排序后的结果 $\{15, -1, 4, 8, 20, 9, 7\}$，可以看出数据被分为 4 组：\\
       - 第 1 组：$\{15, 8\}$\\
       - 第 2 组：$\{9, 20\}$\\
       - 第 3 组：$\{7, -1\}$\\
       - 第 4 组：$\{4\}$\\
    3. 每组内分别进行直接插入排序后，得到排序结果。\\
    4. 因此，增量为 \textcolor{red}{4}。\\

\item 快速排序在最坏情况下的时间复杂度与下列哪个算法最坏情况下的时间复杂度相同？（ ）\\
    【北京交通大学 2006 一、7（2 分）】\\  

    A. Shell 排序 \quad B. 堆排序 \quad C. 冒泡排序 \quad D. 基数排序 \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 快速排序在最坏情况下（如序列完全有序或逆序）会退化为 $O(n^2)$ 的时间复杂度。\\
    2. 冒泡排序的最坏时间复杂度也是 $O(n^2)$，因此两者相同。\\
    3. Shell 排序的最坏时间复杂度为 $O(n^{3/2})$，堆排序为 $O(n \log n)$，基数排序为 $O(d(n + k))$，均不同于快速排序的最坏情况。\\
    4. 因此，答案为 \textcolor{red}{C}。\\

\item 下列排序方法中，（ ）在待排序的数据为有序时花费时间反而最多。\\
    【华中科技大学 2007 一、8（2 分）】\\  

    A. 快速排序 \quad B. 插入排序 \quad C. 堆排序 \quad D. 冒泡排序 \\

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 快速排序在初始数据有序时，若基准元素选择不当（如总是选择第一个或最后一个元素），会导致分区极不均匀，时间复杂度退化为 $O(n^2)$。\\
    2. 插入排序和冒泡排序在数据有序时效率最高，时间复杂度接近 $O(n)$。\\
    3. 堆排序的性能与数据的初始有序性无关。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

\item 快速排序算法在最好情况下的时间复杂度是（ ）。\\
    【南京理工大学 2005 一、1（1 分）】\\  

    A. $O(n)$ \quad B. $O(n^2)$ \quad C. $O(n \log n)$ \quad D. $O(\log n)$ \\

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 快速排序在最好情况下，每次分区都能将序列均匀分为两部分，递归深度为 $O(\log n)$，每层分区的时间复杂度为 $O(n)$。\\
    2. 因此，总时间复杂度为 $O(n \log n)$。\\
    3. 因此，答案为 \textcolor{red}{C}。\\ 

    \item 对下列关键字序列用快速排序法进行排序时，速度最快的情形是（ ）。\\
    【北方交通大学 2001 一、18（2 分）】\\  

    A. $\{21, 25, 5, 17, 9, 23, 30\}$ \\  

    B. $\{25, 23, 30, 17, 21, 5, 9\}$ \\  

    C. $\{21, 9, 17, 30, 25, 23, 5\}$ \\  
    
    D. $\{5, 9, 17, 21, 23, 25, 30\}$ \\  

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 快速排序的速度最快时，基准元素能够将序列均匀分割为两部分，递归深度最小。\\
    2. 选项 D 中的序列已经是有序的，快速排序在这种情况下可以通过优化（如三路快排）减少不必要的分区操作，从而达到最快速度。\\
    3. 其他选项的序列无序程度较高，分区过程会导致递归深度增加，影响排序速度。\\
    4. 因此，答案为 \textcolor{red}{D}。\\

    \item 对 $n$ 个记录的线性表进行快速排序，为减少算法的递归深度，以下叙述正确的是（ ）。\\
    【北方交通大学 2000 二、5（2 分）】\\  

    A. 每次分区后，先处理较短的部分 \\  
    B. 每次分区后，先处理较长的部分 \\  
    C. 与算法每次分区后的处理顺序无关 \\  
    D. 以上三者都不对 \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 快速排序中，先处理较短的部分可以减少递归深度，从而降低递归栈的空间消耗。\\
    2. 先处理较长的部分会增加递归深度，导致栈溢出的风险更高。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 快速排序在最坏情况下的时间复杂度是（ ），比（ ）的性能差。\\
    【山东工业大学 1995 二、2（4 分）】\\  

    A. $O(n \log n)$ \quad B. $O(n^2)$ \quad C. $O(n^3)$ \quad D. 堆排序 \quad E. 冒泡排序 \quad F. 选择排序 \\  

    答案: \textcolor{red}{B, D} \\

    解析：\\
    1. 快速排序在最坏情况下（如序列完全有序或逆序）会退化为 $O(n^2)$ 的时间复杂度。\\
    2. 堆排序的时间复杂度为 $O(n \log n)$，在最坏情况下性能优于快速排序。\\
    3. 因此，答案为 \textcolor{red}{B, D}。\\

\item 当 $n$ 个整型数据有序时，对这些数据用快速排序算法排序，则时间复杂度是（1）；当用递归算法求 $n!$ 时，算法的时间复杂度是（2），则 $(1) - (2) = $（ ）。\\
    【南京理工大学 1999 一（6-7）（4 分）】\\  

    A. $O(n)$ \quad B. $O(n \log n)$ \quad C. $O(n^2)$ \quad D. $O(\log n)$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 快速排序在数据有序时，若基准元素选择不当，时间复杂度退化为 $O(n^2)$。\\
    2. 递归算法求 $n!$ 的时间复杂度为 $O(n)$。\\
    3. $(1) - (2) = O(n^2) - O(n) = O(n^2)$。\\
    4. 因此，答案为 \textcolor{red}{C}。\\

\item 对各种内部排序方法来说，（ ）。\\
    【华南理工大学 2006 一、3（2 分）】\\  

    A. 快速排序时间性能最佳 \\  
    B. 基数排序和归并排序是稳定的排序方法 \\  
    C. 快速排序是一种选择排序 \\  
    D. 堆排序所用的辅助空间比较大 \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 快速排序的时间性能在平均情况下最佳，但在最坏情况下可能退化为 $O(n^2)$。\\
    2. 基数排序和归并排序是稳定的排序方法，能够保持相同关键字的相对顺序。\\
    3. 快速排序是一种分治法排序，而非选择排序。\\
    4. 堆排序的辅助空间复杂度为 $O(1)$，并不大。\\
    5. 因此，答案为 \textcolor{red}{B}。\\

    \item 在含有 $n$ 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在（ ）位置上。\\
    【中科院计算所 2000 一、4（2 分）】\\  

    A. $\lfloor n/2 \rfloor$ \quad B. $\lfloor n/2 \rfloor - 1$ \quad C. $1$ \quad D. $\lfloor n/2 \rfloor + 2$ \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 在小根堆中，堆顶元素最小，关键字最大的记录一定存储在叶子节点中。\\
    2. 对于完全二叉树，叶子节点的索引范围是从 $\lfloor n/2 \rfloor$ 到 $n$。\\
    3. 因此，关键字最大的记录有可能存储在 $\lfloor n/2 \rfloor$ 位置上。\\
    4. 因此，答案为 \textcolor{red}{A}。\\

\item 若对 $n$ 个元素进行堆排序，则在初始建堆的过程中需要进行（ ）次筛选。\\
    【北京理工大学 2005 一、5（1 分）】\\  

    A. $n$ \quad B. $n/2$ \quad C. $(n-1)/2$ \quad D. $n$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 堆排序的初始建堆过程是从最后一个非叶子节点开始向上调整堆。\\
    2. 非叶子节点的个数为 $(n-1)/2$，因此需要进行 $(n-1)/2$ 次筛选操作。\\
    3. 答案为 \textcolor{red}{C}。\\

    \item 以下序列不是堆的是（ ）。\\
    【西安电子科技大学 2001 应用一、5（2 分）】\\  

    A. $\{100, 85, 98, 77, 80, 60, 82, 40, 20, 10, 66\}$ \\  

    B. $\{100, 98, 85, 82, 80, 77, 66, 60, 40, 20, 10\}$ \\  

    C. $\{10, 20, 40, 60, 66, 77, 80, 82, 85, 98, 100\}$ \\  

    D. $\{100, 85, 40, 77, 80, 60, 66, 98, 82, 10, 20\}$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 堆是一种完全二叉树，分为大根堆和小根堆：\\
       - 大根堆要求每个节点的值都大于或等于其子节点的值。\\
       - 小根堆要求每个节点的值都小于或等于其子节点的值。\\
    2. 选项 A 和 B 满足大根堆的性质，选项 D 也满足大根堆的性质。\\
    3. 选项 C 是一个递增序列，不符合堆的性质，因此不是堆。\\
    4. 因此，答案为 \textcolor{red}{C}。\\

    \item 一组关键字为 $\{46, 79, 56, 38, 40, 84\}$，则利用堆排序的方法建立大根堆的初始堆为（ ）。\\
    【北京交通大学 2006 一、8（2 分）】\\  

    A. $\{79, 46, 56, 38, 40, 84\}$ \\  

    B. $\{84, 79, 56, 38, 40, 46\}$ \\  

    C. $\{84, 79, 56, 46, 40, 38\}$ \\  

    D. $\{84, 56, 79, 40, 46, 38\}$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 堆排序的第一步是构建大根堆，大根堆要求每个节点的值都大于或等于其子节点的值。\\
    2. 对于序列 $\{46, 79, 56, 38, 40, 84\}$，从最后一个非叶子节点开始调整堆：\\
       - 首先调整节点 $56$，将其与子节点 $84$ 交换，堆变为 $\{46, 79, 84, 38, 40, 56\}$；\\
       - 然后调整节点 $46$，将其与子节点 $84$ 交换，堆变为 $\{84, 79, 56, 38, 40, 46\}$；\\
       - 最后调整节点 $79$，无需交换，最终堆为 $\{84, 79, 56, 46, 40, 38\}$。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

    \item 在对 $n$ 个元素的序列进行排序时，堆排序所需要的附加存储空间是（ ）。\\
    【西安电子科技大学 2001 应用一、10（2 分）】\\  

    A. $O(\log n)$ \quad B. $O(1)$ \quad C. $O(n)$ \quad D. $O(n \log n)$ \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 堆排序是一种原地排序算法，其附加存储空间复杂度为 $O(1)$，因为它只需要常量级的额外空间来进行堆的调整。\\
    2. 因此，答案为 \textcolor{red}{B}。\\

\item 对 $n$ 个记录的文件进行堆排序，最坏情况下的执行时间是（ ）。\\
    【北方交通大学 2001 一、9（2 分）】\\  

    A. $O(\log n)$ \quad B. $O(n)$ \quad C. $O(n \log n)$ \quad D. $O(n^2)$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 堆排序的时间复杂度为 $O(n \log n)$，无论在最坏情况下还是平均情况下，时间复杂度都保持一致。\\
    2. 因此，答案为 \textcolor{red}{C}。\\

    \item 有一组数据 $\{15, 9, 7, 8, 20, -1, 7, 4\}$，用堆排序的筛选方法建立的初始堆为（ ）。\\
    【南京理工大学 1996 二、5（2 分）】\\  

    A. $\{-1, 4, 8, 9, 20, 7, 15, 7\}$ \\  

    B. $\{-1, 7, 15, 7, 4, 8, 20, 9\}$ \\  

    C. $\{-1, 4, 7, 8, 20, 15, 7, 9\}$ \\  

    D. A、B、C 均不对 \\  

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 堆排序的初始堆是通过从最后一个非叶子节点开始向上调整堆来构建的。\\
    2. 对于数据 $\{15, 9, 7, 8, 20, -1, 7, 4\}$，构建大根堆的过程如下：\\
       - 从节点 $8$ 开始调整，逐步向上调整堆的结构；\\
       - 最终形成的大根堆应该满足堆的性质，即每个节点的值都大于或等于其子节点的值。\\
    3. 选项 A、B 和 C 中的堆均不符合堆的性质，因此答案为 \textcolor{red}{D}。\\

    \item 归并排序中，归并的趟数是（ ）。\\
    【南京理工大学 2000 一、19（1.5 分）】\\  

    A. $O(n)$ \quad B. $O(\log n)$ \quad C. $O(n \log n)$ \quad D. $O(n^2)$ \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 归并排序的趟数取决于将序列分割到单个元素所需的次数。\\
    2. 每次分割将序列长度减半，因此需要 $O(\log n)$ 趟归并。\\
    3. 因此，答案为 \textcolor{red}{B}。\\

\item 在排序算法中，每一项都与其他各项进行比较，计算出小于该项的项的个数，以确定该项的位置叫（ ）。\\
    【北京邮电大学 2000 二、6（2 分）】\\  

    A. 插入排序 \quad B. 枚举排序 \quad C. 选择排序 \quad D. 交换排序 \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 枚举排序的特点是每一项都与其他各项进行比较，计算出小于该项的项的个数，以确定该项的位置。\\
    2. 插入排序、选择排序和交换排序的排序过程与此描述不符。\\
    3. 因此，答案为 \textcolor{red}{B}。\\

\item 就分类算法所用的辅助空间而言，堆排序、快速排序和归并排序的关系是（ ）。\\
    【哈尔滨工业大学 2004 二、6（1 分）】\\  

    A. 堆排序 < 快速排序 < 归并排序 \\  
    B. 堆排序 < 归并排序 < 快速排序 \\  
    C. 堆排序 > 归并排序 > 快速排序 \\  
    D. 堆排序 > 快速排序 > 归并排序 \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 堆排序的辅助空间复杂度为 $O(1)$，快速排序为 $O(\log n)$（递归栈空间），归并排序为 $O(n)$（需要额外的数组）。\\
    2. 因此，答案为 \textcolor{red}{A}。\\

\item 对给出的一组关键字 $\{13, 6, 19, 30, 10, 18\}$，若按关键字非递减排序，第一趟排序结果为 $\{13, 6, 18, 30, 10, 19\}$，则可能采用的排序算法是（ ）。\\
    【电子科技大学 2005 一、5（1 分）】\\  

    A. 简单选择排序 \quad B. 快速排序 \quad C. 希尔排序 \quad D. 二路归并排序 \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 快速排序的第一趟排序会选择一个基准元素（如 $13$），将序列分为两部分：左侧小于基准，右侧大于基准。\\
    2. 第一趟排序结果 $\{13, 6, 18, 30, 10, 19\}$ 符合快速排序的分区规则。\\
    3. 简单选择排序、希尔排序和二路归并排序的排序过程与此结果不符。\\
    4. 因此，答案为 \textcolor{red}{B}。\\

    \item （多选）在下列排序中，（ ）方法的平均时间复杂度为 $O(n \log n)$。\\
    【华中科技大学 2007 二、20（2 分）】\\  

    A. 选择排序 \quad B. 快速排序 \quad C. 归并排序 \quad D. 基数排序 \\  

    答案: \textcolor{red}{B, C} \\

    解析：\\
    1. 快速排序和归并排序的平均时间复杂度均为 $O(n \log n)$，适用于大规模数据排序。\\
    2. 选择排序的时间复杂度为 $O(n^2)$，基数排序的时间复杂度为 $O(d(n + k))$，与 $O(n \log n)$ 不同。\\
    3. 因此，答案为 \textcolor{red}{B, C}。\\

\item 排序方法有许多种，(1) 方法从未排序的序列中依次取出元素，与已排序序列（初始时为空）中的元素作比较，将其放入已排序序列的正确位置上；(2) 方法从未排序的序列中挑选元素，并将其依次放入已排序序列（初始时为空）的一端；交换排序方法是对序列中的元素进行一系列比较，当被比较的两元素逆序时，进行交换，(3) 和 (4) 是基于这类方法的两种排序方法，而 (4) 是比 (3) 效率更高的方法；(5) 方法是基于选择排序的一种排序方法，是完全二叉树结构的一个重要应用。\\
    【北方交通大学 1999 一、3（5 分）】\\  

    A. 选择排序 \quad B. 快速排序 \quad C. 插入排序 \quad D. 冒泡排序 \\  
    E. 归并排序 \quad F. 希尔排序 \quad G. 堆排序 \quad H. 基数排序 \\  

    答案: \textcolor{red}{C, A, D, B, G} \\

    解析：\\
    1. (1) 插入排序：从未排序序列中依次取出元素，与已排序序列比较后插入到正确位置。\\
    2. (2) 选择排序：从未排序序列中挑选最小（或最大）元素，放入已排序序列的一端。\\
    3. (3) 冒泡排序：通过交换逆序的相邻元素进行排序。\\
    4. (4) 快速排序：交换排序的一种改进方法，效率更高。\\
    5. (5) 堆排序：基于选择排序的一种方法，利用完全二叉树结构实现。\\
    6. 因此，答案为 \textcolor{red}{C, A, D, B, G}。\\

\item 设要将序列 $\{q, h, c, y, p, a, m, s, r, d, f, x\}$ 中的关键字按字母升序重新排序：\\

    \begin{enumerate}
        \item （ ）是初始步长为 4 的 Shell 排序一趟扫描的结果；\\
        \item （ ）是对排序初始建堆的结果；\\
        \item （ ）是以第一个元素为分界元素的快速一趟扫描的结果。\\
    \end{enumerate}

    从下面供选择的答案中选出正确答案填入括号内。\\
    【厦门大学 2000 六、3（16\% / 3 分）】\\

    \begin{enumerate}[A.]
        \item $f, h, c, d, p, a, m, q, r, s, y, x$\\
        \item $p, a, c, s, q, d, f, x, r, h, m, y$\\
        \item $a, d, c, r, f, q, m, s, y, p, h, x$\\
        \item $h, c, q, p, a, m, s, r, d, f, x, y$\\
        \item $h, q, c, y, a, p, m, s, d, r, f, x$\\
    \end{enumerate}

    答案: \textcolor{red}{D, B, C} \\

    解析：\\
    1. 初始步长为 4 的 Shell 排序一趟扫描结果为 $h, c, q, p, a, m, s, r, d, f, x, y$，对应选项 D。\\
    2. 初始建堆的结果为 $p, a, c, s, q, d, f, x, r, h, m, y$，对应选项 B。\\
    3. 快速排序以第一个元素为分界元素的结果为 $a, d, c, r, f, q, m, s, y, p, h, x$，对应选项 C。\\
    4. 因此，答案为 \textcolor{red}{D, B, C}。\\
    \item $n$ 个英文单词，每个单词长度基本相等，为 $m$，当 $n ≥ 50$ 且 $m < 5$ 时，时间复杂度最佳的排序方法是（ ）。\\
    【大连理工大学 2008 一、4】\\  

    A. 快速排序 \quad B. 归并排序 \quad C. 基数排序 \quad D. 直接插入排序 \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 基数排序适合处理长度较短且固定的字符串（如英文单词），其时间复杂度为 $O(d(n + k))$，其中 $d$ 为关键字的位数，$k$ 为每个位的取值范围。\\
    2. 当 $m < 5$ 时，基数排序的效率优于基于比较的排序方法（如快速排序和归并排序）。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 将两个各有 $n$ 个元素的有序表归并成一个有序表，其最少的比较次数是（ ）。\\
    【中科院计算所 1998 二、7（2 分）；中国科技大学 1998 二、7（2 分）】\\  

    A. $n$ \quad B. $2n-1$ \quad C. $2n$ \quad D. $n-1$ \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 归并两个有序表时，每次比较后将较小的元素放入结果表中，直到一个表为空。\\
    2. 最少的比较次数为 $2n-1$，因为最后一次比较后无需再比较剩余的元素。\\
    3. 因此，答案为 \textcolor{red}{B}。\\

\item 基于比较方法的 $n$ 个数据的内部排序，最坏情况下的时间复杂度能达到的最好下界是（ ）。\\
    【南京理工大学 1996 一、10（2 分）】\\  

    A. $O(n \log n)$ \quad B. $O(\log n)$ \quad C. $O(n)$ \quad D. $O(n^2)$ \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 基于比较的排序算法（如快速排序、归并排序、堆排序）的时间复杂度下界为 $O(n \log n)$，这是由决策树模型决定的。\\
    2. 因此，答案为 \textcolor{red}{A}。\\

\item 已知待排序的 $n$ 个元素可分为 $n / k$ 个组，每个组包含 $k$ 个元素，且任一组内的各元素均分别大于前一组内的所有元素和小于后一组内的所有元素，若采用基于比较的排序，其时间下界应为（ ）。\\
    【中国科技大学 1998 二、9（2 分）；北京大学 2016 一、10（2 分）】\\  

    A. $O(n \log_2 n)$ \quad B. $O(n \log_2 k)$ \quad C. $O(k \log_2 n)$ \quad D. $O(k \log_2 k)$ \\  

    答案: \textcolor{red}{B} \\

    解析：\\
    1. 每组内的排序时间复杂度为 $O(k \log_2 k)$，总共有 $n / k$ 个组，因此总时间复杂度为 $O(n \log_2 k)$。\\
    2. 因此，答案为 \textcolor{red}{B}。\\

\item 采用败者树进行多路平衡归并时，总的（包括访外）归并效率与 $k$（路数）（ ）有关。\\
    【北京工业大学 2001 一、4（2 分）】\\  

    A. 有关 \quad B. 无关 \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 败者树是一种多路归并的高效实现，其归并效率与路数 $k$ 有关。\\
    2. 路数越多，归并树的高度越大，比较次数也会增加。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

    \item 对 $\{05, 46, 13, 55, 94, 17, 42\}$ 进行基数排序，一趟排序的结果是（ ）。\\
    【武汉理工大学 2004 一、10（3 分）】\\  

    A. $\{05, 46, 13, 55, 94, 17, 42\}$ \\  
    B. $\{05, 13, 17, 42, 46, 55, 94\}$ \\  
    C. $\{42, 13, 94, 05, 55, 46, 17\}$ \\  
    D. $\{05, 13, 46, 55, 17, 42, 94\}$ \\  

    答案: \textcolor{red}{D} \\

    解析：\\
    1. 基数排序按位进行排序，一趟排序通常是按个位或十位进行分配和收集。\\
    2. 按个位排序后，序列变为 $\{05, 13, 46, 55, 17, 42, 94\}$。\\
    3. 因此，答案为 \textcolor{red}{D}。\\

\item 若数据元素序列 $\{15, 18, 22, 9, 35, 26, 4, 6\}$ 是采用下列排序方法之一得到的第二趟排序后的结果（要求从小到大排序），则该排序算法只能是（ ）。\\
    【北京工业大学 2017 一、10（2 分）】\\  

    A. 堆排序 \quad B. 冒泡排序 \quad C. 简单选择排序 \quad D. 直接插入排序 \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 简单选择排序每一趟从未排序部分中选出最小值，放到已排序部分的末尾。\\
    2. 第二趟排序后，序列变为 $\{4, 6, 22, 9, 35, 26, 15, 18\}$，符合简单选择排序的特点。\\
    3. 因此，答案为 \textcolor{red}{C}。\\

\item 数据表 $A$ 中每个元素距其最终位置较近，最省时间的排序算法是（ ）。\\
    【烟台大学 2019 一、13（2 分）】\\  

    A. 插入排序 \quad B. 堆排序 \quad C. 直接选择排序 \quad D. 快速排序 \\  

    答案: \textcolor{red}{A} \\

    解析：\\
    1. 插入排序在数据接近有序时效率最高，其时间复杂度接近 $O(n)$。\\
    2. 堆排序、直接选择排序和快速排序在这种情况下效率不如插入排序高效。\\
    3. 因此，答案为 \textcolor{red}{A}。\\

\item 下面序列中满足大根堆条件的是（ ）。\\
    【北京工业大学 2018 一、10（2 分）】\\  

    A. $\{49, 37, 40, 28, 41, 16, 25, 18\}$ \\  
    B. $\{34, 23, 45, 6, 24, 7, 15, 12\}$ \\  
    C. $\{52, 37, 49, 28, 16, 42, 39, 19\}$ \\  
    D. $\{55, 43, 45, 48, 52, 29, 77, 12\}$ \\  

    答案: \textcolor{red}{C} \\

    解析：\\
    1. 大根堆要求每个节点的值都大于或等于其子节点的值。\\
    2. 选项 C 中的序列满足大根堆的性质，根节点 $52$ 大于其子节点 $37$ 和 $49$，其他节点也满足堆的性质。\\
    3. 其他选项不符合大根堆的定义。\\
    4. 因此，答案为 \textcolor{red}{C}。\\
\end{enumerate}
\end{document}
